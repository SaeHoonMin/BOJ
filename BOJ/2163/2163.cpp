#include <iostream>
using namespace::std;
int dp[301][301];

int main(void)
{
	int m, n;
	cin >> n >> m;

	/*
		dp[n][m] = n * m 초콜렛을 쪼갤 때 필요한 최소 회수

		규칙
		1. 기본적으로 n or m == 1이면,   1이아닌 n또는 m-1번을 잘라야 함.
		2. 예를 들어 2*3초콜렛을 세로로 한번 쪼개면, 2*1 1개와 2*2 한개가 나옴. 
		   반대로, 가로로 쪼개면 3*1 2개가 나옴.

		그렇다면 점화식은 어떻게 될까...
		쪼갠다는 것 -> 현재의 크기보다 작아지는것, 즉 sub problem.
		dp[n][m] min ( sum(세로로 쪼갰을 때 초콜렛들 ) , sum(가로로 쪼갰을 때 초콜렛들) )

		그러나....................
		n이나 m으로 한칸씩 증가한다면 , 즉2*2 -> 2*3 -> 2*4로 증가하면
		1*1의 총 초콜릿 개수는 4->6->8
		총 자르기 위한 회수는 3->5->7

		반대로 n,m모두 증가하면. 즉 2*2 -> 3*3 -> 4*4 
		                         4  -> 9 -> 16
								 3  -> 8 -> 
		결국은 n*m -1이 규칙임.
	*/

	cout << n*m - 1;

}